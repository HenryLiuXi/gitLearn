<!-- 创建版本库 -->
<!-- 操作命令 -->
<!-- 添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。 -->
<!-- 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。
所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 
第一步
-->
mkdir <文件夹名>
cd <文件夹名>
<!-- pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 -->
pwd           

<!-- 第二步  通过git init命令把这个目录变成Git可以管理的仓库：-->
git init
<!-- 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。
如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 
也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。-->
<!-- =========================================================================================================== -->
<!-- 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。
和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 -->
<!-- 第一步，用命令git add告诉Git，把文件添加到仓库： -->
git add <指定文件名>
<!-- 也可以通过 'git add .'将当前文件夹所以文件提交 -->
<!-- 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 -->

<!-- 第二步，用命令git commit告诉Git，把文件提交到仓库： -->
git commit -m '本次提交的说明'

<!-- 时光机穿梭 版本切换 -->
<!-- git status命令可以让我们时刻掌握仓库当前的状态  要随时掌握工作区的状态，使用git status命令-->
git status

<!-- git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以显示文件名目前产品与上个版本存成的差异。如果‘git status’告诉你有文件被修改过，用‘git diff’可以查看修改内容 -->
git diff <文件名>

<!-- 用HEAD表示当前版本 上一个版本就是HEAD^ 上上一个版本就是HEAD^^ 当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100-->
git reset --hard HEAD^

<!-- HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id -->
git reset --hard <版本ID>

<!-- 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本 -->
git log

<!-- 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 -->
git reflog

<!-- ======================================================================================================================= -->
<!-- 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 -->
<!-- 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 
可以参考图片

前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
-->
<!-- 如果不用git add到暂存区，那就不会加入到commit中 -->

<!-- git checkout -- file可以丢弃工作区的修改： -->
git checkout -- <文件名>
<!-- git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 -->

<!-- 用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区： -->
git reset HEAD <文件名>
<!-- git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 -->

<!-- 删除文件 -->
<!-- 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： -->
rm <文件名>
<!-- Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： -->
<!-- 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： -->
<!-- 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 -->
git rm <文件名>


<!-- 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。
现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： -->

git remote add origin 'git地址'




<!-- ============================================================================================================================================ -->
<!-- 远程仓库 -->
<!-- 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： -->
ssh-keygen -t rsa -C "邮箱名"
<!-- 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 -->

<!-- 我们根据GitHub的提示，在本地的learngit仓库下运行命令： -->
git remote add origin <SSH链接>
<!-- 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 -->

<!-- git push命令，实际上是把当前分支master推送到远程。 -->
git push -u origin master
<!-- 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 -->

<!-- 从现在起，只要本地作了提交，就可以通过命令： -->
git push origin master

<!-- 要关联一个远程库，使用命令git remote add origin  <SSH链接>；
关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；
 -->


<!-- ============================================================================================================= -->
<!-- 分支管理 -->
<!-- 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：图一 
每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。-->
<!-- 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：图二 
你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！-->
<!-- 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：图三 -->
<!-- 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：图四 -->
<!-- 所以Git合并分支也很快！就改改指针，工作区内容也不变！
合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：图五 -->

<!-- 首先，我们创建dev分支，然后切换到dev分支： -->
git checkout -b dev
<!-- git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： -->
git branch dev
git checkout dev

<!-- 用git branch命令查看当前分支： 
git branch命令会列出所有分支，当前分支前面会标一个*号。-->
git branch

<!-- 我们把dev分支的工作成果合并到master分支上： -->
git merge dev

<!-- 合并完成后，就可以放心地删除dev分支了： -->
git branch -d dev

<!-- 删除后，查看branch，就只剩下master分支了： -->
git branch

<!-- 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 -->

<!-- switch
我们注意到切换分支使用git checkout <branch>，而前面讲过的撤销修改则是git checkout -- <file>，同一个命令，有两种作用，确实有点令人迷惑。
实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：
创建并切换到新的dev分支，可以使用： -->
git switch -c dev

<!-- 直接切换到已有的master分支，可以使用： -->
git switch master

<!-- Git鼓励大量使用分支
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>或者git switch <name>
创建+切换分支：git checkout -b <name>或者git switch -c <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name> -->

<!-- 解决分支冲突 -->
