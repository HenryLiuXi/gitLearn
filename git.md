<!-- 创建版本库 -->
<!-- 操作命令 -->
<!-- 添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。 -->
<!-- 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。
所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 
第一步
-->
mkdir <文件夹名>
cd <文件夹名>
<!-- pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 -->
pwd           

<!-- 第二步  通过git init命令把这个目录变成Git可以管理的仓库：-->
git init
<!-- 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。
如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 
也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。-->
<!-- =========================================================================================================== -->
<!-- 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。
和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 -->
<!-- 第一步，用命令git add告诉Git，把文件添加到仓库： -->
git add <指定文件名>
<!-- 也可以通过 'git add .'将当前文件夹所以文件提交 -->
<!-- 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 -->

<!-- 第二步，用命令git commit告诉Git，把文件提交到仓库： -->
git commit -m '本次提交的说明'

<!-- 时光机穿梭 版本切换 -->
<!-- git status命令可以让我们时刻掌握仓库当前的状态  要随时掌握工作区的状态，使用git status命令-->
git status

<!-- git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以显示文件名目前产品与上个版本存成的差异。如果‘git status’告诉你有文件被修改过，用‘git diff’可以查看修改内容 -->
git diff <文件名>

<!-- 用HEAD表示当前版本 上一个版本就是HEAD^ 上上一个版本就是HEAD^^ 当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100-->
git reset --hard HEAD^

<!-- HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id -->
git reset --hard <版本ID>

<!-- 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本 -->
git log

<!-- 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 -->
git reflog

<!-- ======================================================================================================================= -->
<!-- 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 -->
<!-- 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 
可以参考图片

前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
-->
<!-- 如果不用git add到暂存区，那就不会加入到commit中 -->

<!-- git checkout -- file可以丢弃工作区的修改： -->
git checkout -- <文件名>
<!-- git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 -->

<!-- 用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区： -->
git reset HEAD <文件名>
<!-- git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 -->

<!-- 删除文件 -->
<!-- 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： -->
rm <文件名>
<!-- Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： -->
<!-- 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： -->
<!-- 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 -->
git rm <文件名>


<!-- 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。
现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： -->

git remote add origin 'git地址'




<!-- ============================================================================================================================================ -->
<!-- 远程仓库 -->
<!-- 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： -->
ssh-keygen -t rsa -C "邮箱名"
<!-- 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 -->

<!-- 我们根据GitHub的提示，在本地的learngit仓库下运行命令： -->
git remote add origin <SSH链接>
<!-- 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 -->

<!-- git push命令，实际上是把当前分支master推送到远程。 -->
git push -u origin master
<!-- 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 -->

<!-- 从现在起，只要本地作了提交，就可以通过命令： -->
git push origin master

<!-- 要关联一个远程库，使用命令git remote add origin  <SSH链接>；
关联后，使用命令git push -u origin master第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；
 -->